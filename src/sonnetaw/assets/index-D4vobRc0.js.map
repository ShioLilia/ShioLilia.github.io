{"version":3,"file":"index-D4vobRc0.js","sources":["../../src/dictionary.ts","../../src/textProcessor.ts","../../src/analyzer.ts","../../src/config.ts","../../src/main.ts"],"sourcesContent":["import type { PronunciationDict, Syllable, WordAnalysis } from './types';\r\n\r\n/**\r\n * Dictionary service for loading and querying pronunciation data\r\n */\r\nexport class DictionaryService {\r\n  private dict: PronunciationDict = {};\r\n  private currentLanguage: string = 'en'; // 当前加载的语言\r\n\r\n  /**\r\n   * Load pronunciation dictionary from JSON data\r\n   */\r\n  async loadDictionary(dictData: PronunciationDict, languageCode: string = 'en'): Promise<void> {\r\n    this.dict = dictData;\r\n    this.currentLanguage = languageCode;\r\n  }\r\n\r\n  /**\r\n   * Get current language code\r\n   */\r\n  getCurrentLanguage(): string {\r\n    return this.currentLanguage;\r\n  }\r\n\r\n  /**\r\n   * Look up a word in the dictionary\r\n   * Returns the first pronunciation if multiple exist\r\n   */\r\n  lookup(word: string): string[] | null {\r\n    const normalized = word.toLowerCase().replace(/[^a-z']/g, '');\r\n    const pronunciations = this.dict[normalized];\r\n    if (!pronunciations || pronunciations.length === 0) {\r\n      return null;\r\n    }\r\n    return pronunciations[0]; // Return first pronunciation\r\n  }\r\n\r\n  /**\r\n   * Extract syllables from phonemes\r\n   * A syllable contains one vowel sound (phonemes ending in 0, 1, or 2)\r\n   */\r\n  extractSyllables(phonemes: string[]): Syllable[] {\r\n    const syllables: Syllable[] = [];\r\n    let currentSyllable: string[] = [];\r\n    let currentStress: 0 | 1 | 2 = 0;\r\n\r\n    for (const phoneme of phonemes) {\r\n      currentSyllable.push(phoneme);\r\n      \r\n      // Check if this phoneme contains stress information (ends with 0, 1, or 2)\r\n      const stressMatch = phoneme.match(/[012]$/);\r\n      if (stressMatch) {\r\n        currentStress = parseInt(stressMatch[0]) as 0 | 1 | 2;\r\n        syllables.push({\r\n          phonemes: currentSyllable,\r\n          stress: currentStress\r\n        });\r\n        currentSyllable = [];\r\n        currentStress = 0;\r\n      }\r\n    }\r\n\r\n    // Add any remaining consonants to the last syllable\r\n    if (currentSyllable.length > 0 && syllables.length > 0) {\r\n      syllables[syllables.length - 1].phonemes.push(...currentSyllable);\r\n    }\r\n\r\n    return syllables;\r\n  }\r\n\r\n  /**\r\n   * Extract rhyme key from phonemes\r\n   * The rhyme key consists of phonemes from the last primary stressed vowel to the end\r\n   */\r\n  extractRhymeKey(phonemes: string[]): string {\r\n    // Find the last vowel (phoneme with stress marker 0, 1, or 2)\r\n    let lastVowelIndex = -1;\r\n    for (let i = phonemes.length - 1; i >= 0; i--) {\r\n      if (phonemes[i].match(/[012]$/)) {\r\n        lastVowelIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (lastVowelIndex === -1) {\r\n      // No vowel found in this word (all consonants), return empty\r\n      // The caller should look for the previous vowel in the line\r\n      return '';\r\n    }\r\n\r\n    // Return from last vowel to end, removing stress markers\r\n    return phonemes\r\n      .slice(lastVowelIndex)\r\n      .map(p => p.replace(/[012]$/, ''))\r\n      .join('-');\r\n  }\r\n\r\n  /**\r\n   * Analyze a single word\r\n   */\r\n  analyzeWord(word: string): WordAnalysis {\r\n    const phonemes = this.lookup(word);\r\n    \r\n    if (!phonemes) {\r\n      return {\r\n        word: word.toLowerCase(),\r\n        originalWord: word,\r\n        syllables: [],\r\n        rhymeKey: '',\r\n        found: false\r\n      };\r\n    }\r\n\r\n    const syllables = this.extractSyllables(phonemes);\r\n    const rhymeKey = this.extractRhymeKey(phonemes);\r\n\r\n    return {\r\n      word: word.toLowerCase(),\r\n      originalWord: word,\r\n      syllables,\r\n      rhymeKey,\r\n      found: true\r\n    };\r\n  }\r\n}\r\n","/**\r\n * Text processing utilities for preprocessing sonnet input\r\n */\r\n\r\n/**\r\n * Split text into lines, preserving empty lines\r\n */\r\nexport function splitLines(text: string): string[] {\r\n  return text.split('\\n');\r\n}\r\n\r\n/**\r\n * Tokenize a line into words\r\n * Preserves the original words before removing punctuation\r\n */\r\nexport function tokenizeLine(line: string): string[] {\r\n  // Split on whitespace and filter empty strings\r\n  return line.trim().split(/\\s+/).filter(word => word.length > 0);\r\n}\r\n\r\n/**\r\n * Remove punctuation from a word but preserve apostrophes\r\n * for contractions like \"it's\" or \"don't\"\r\n */\r\nexport function removePunctuation(word: string): string {\r\n  // First normalize all apostrophe variants to ASCII apostrophe\r\n  const normalized = word.replace(/['']/g, \"'\");\r\n  // Keep letters and apostrophes, remove everything else\r\n  return normalized.replace(/[^a-zA-Z']/g, '');\r\n}\r\n\r\n/**\r\n * Preprocess text: split lines and tokenize\r\n */\r\nexport function preprocessText(text: string): { lines: string[], tokens: string[][] } {\r\n  const lines = splitLines(text);\r\n  const tokens = lines.map(line => tokenizeLine(line));\r\n  return { lines, tokens };\r\n}\r\n","import type {\r\n  LineAnalysis,\r\n  SonnetAnalysis,\r\n  SonnetForm,\r\n  StressPattern,\r\n  WordAnalysis\r\n} from './types';\r\nimport { DictionaryService } from './dictionary';\r\nimport { tokenizeLine, removePunctuation } from './textProcessor';\r\n\r\n/**\r\n * Sonnet analyzer service\r\n */\r\nexport class SonnetAnalyzer {\r\n  constructor(private dictionary: DictionaryService) {}\r\n\r\n  /**\r\n   * Analyze a single line of text\r\n   */\r\n  analyzeLine(lineText: string, lineNumber: number): LineAnalysis {\r\n    const words = tokenizeLine(lineText);\r\n    const wordAnalyses: WordAnalysis[] = [];\r\n    const stressPattern: StressPattern = [];\r\n\r\n    for (const word of words) {\r\n      const cleaned = removePunctuation(word);\r\n      if (!cleaned) continue;\r\n\r\n      const analysis = this.dictionary.analyzeWord(cleaned);\r\n      wordAnalyses.push(analysis);\r\n\r\n      // Build stress pattern from syllables\r\n      for (const syllable of analysis.syllables) {\r\n        stressPattern.push(syllable.stress);\r\n      }\r\n    }\r\n\r\n    // Get rhyme key from last word\r\n    const lastWord = wordAnalyses.length > 0 ? wordAnalyses[wordAnalyses.length - 1] : null;\r\n    let rhymeKey = lastWord?.rhymeKey || '';\r\n    \r\n    // If last word has no rhyme key (all consonants), look backward for last vowel in line\r\n    if (rhymeKey === '' && wordAnalyses.length > 0) {\r\n      for (let i = wordAnalyses.length - 1; i >= 0; i--) {\r\n        if (wordAnalyses[i].rhymeKey) {\r\n          rhymeKey = wordAnalyses[i].rhymeKey;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      lineNumber,\r\n      text: lineText,\r\n      words: wordAnalyses,\r\n      stressPattern,\r\n      rhymeKey\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if stress pattern matches expected meter\r\n   * Returns true if valid, false if there are issues\r\n   */\r\n  checkMeter(actual: StressPattern, expected: StressPattern): boolean {\r\n    // If syllable count is way off (more than 2 syllables difference), skip checking\r\n    if (Math.abs(actual.length - expected.length) > 2) {\r\n      return false; // Will be handled as unchecked line\r\n    }\r\n\r\n    // Check if length matches\r\n    if (actual.length !== expected.length) {\r\n      return false;\r\n    }\r\n\r\n    // Check if primary stresses (1) are in the right positions\r\n    // Also check for unstressed positions that should be stressed\r\n    for (let i = 0; i < expected.length; i++) {\r\n      if (expected[i] === 1 && actual[i] !== 1) {\r\n        return false; // Expected stress but got unstressed\r\n      }\r\n      if (expected[i] === 0 && actual[i] === 1) {\r\n        return false; // Expected unstressed but got stress\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Validate rhyme scheme\r\n   */\r\n  validateRhymeScheme(lines: LineAnalysis[], expectedScheme: string[]): {\r\n    valid: boolean;\r\n    issues: string[];\r\n    rhymeGroups: { [letter: string]: number[] }; // Map rhyme letters to line indices\r\n  } {\r\n    const rhymeGroups: { [letter: string]: number[] } = {};\r\n    const rhymeKeys: { [letter: string]: string[] } = {};\r\n    const issues: string[] = [];\r\n\r\n    // Group lines by their rhyme scheme letter\r\n    for (let i = 0; i < Math.min(lines.length, expectedScheme.length); i++) {\r\n      const letter = expectedScheme[i];\r\n      const rhymeKey = lines[i].rhymeKey;\r\n\r\n      if (!rhymeGroups[letter]) {\r\n        rhymeGroups[letter] = [];\r\n        rhymeKeys[letter] = [];\r\n      }\r\n      rhymeGroups[letter].push(i);\r\n      rhymeKeys[letter].push(rhymeKey);\r\n    }\r\n\r\n    // Check that all lines in each rhyme group have the same rhyme key\r\n    for (const [letter, lineIndices] of Object.entries(rhymeGroups)) {\r\n      // Skip single-line rhyme groups (no checking needed)\r\n      if (lineIndices.length <= 1) {\r\n        continue;\r\n      }\r\n\r\n      const rhymes = rhymeKeys[letter];\r\n      const validRhymes = rhymes.filter(r => r !== '');\r\n      const uniqueRhymes = new Set(validRhymes);\r\n      \r\n      // Check if there are multiple different rhymes\r\n      if (uniqueRhymes.size > 1) {\r\n        issues.push(`Rhyme group ${letter} has inconsistent rhymes: ${Array.from(uniqueRhymes).join(', ')}`);\r\n      }\r\n      \r\n      // Check for missing rhyme keys (words not in dictionary)\r\n      if (validRhymes.length < rhymes.length) {\r\n        issues.push(`Rhyme group ${letter} contains words not found in dictionary`);\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: issues.length === 0,\r\n      issues,\r\n      rhymeGroups\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Analyze an entire sonnet\r\n   */\r\n  analyzeSonnet(text: string, form: SonnetForm): SonnetAnalysis {\r\n    const lines = text.split('\\n').filter(line => line.trim().length > 0);\r\n    \r\n    const lineAnalyses: LineAnalysis[] = lines.map((line, index) => {\r\n      const analysis = this.analyzeLine(line, index + 1);\r\n      \r\n      // Check meter\r\n      analysis.expectedStressPattern = form.meter.stressPattern;\r\n      analysis.meterValid = this.checkMeter(\r\n        analysis.stressPattern,\r\n        form.meter.stressPattern\r\n      );\r\n\r\n      return analysis;\r\n    });\r\n\r\n    // Validate rhyme scheme\r\n    const rhymeValidation = this.validateRhymeScheme(lineAnalyses, form.rhymeScheme);\r\n\r\n    // Check meter validity\r\n    const meterIssues: string[] = [];\r\n    for (const line of lineAnalyses) {\r\n      // Skip lines that are too far off or have no valid words\r\n      if (line.words.length === 0 || Math.abs(line.stressPattern.length - form.meter.stressPattern.length) > 2) {\r\n        continue;\r\n      }\r\n      \r\n      if (!line.meterValid) {\r\n        meterIssues.push(\r\n          `Line ${line.lineNumber}: Expected ${form.meter.stressPattern.length} syllables ` +\r\n          `with pattern ${form.meter.stressPattern.join('')}, ` +\r\n          `got ${line.stressPattern.length} syllables with pattern ${line.stressPattern.join('')}`\r\n        );\r\n      }\r\n    }\r\n\r\n    return {\r\n      lines: lineAnalyses,\r\n      form,\r\n      rhymeSchemeValid: rhymeValidation.valid,\r\n      meterValid: meterIssues.length === 0,\r\n      rhymeIssues: rhymeValidation.issues,\r\n      meterIssues,\r\n      rhymeGroups: rhymeValidation.rhymeGroups\r\n    };\r\n  }\r\n}\r\n","/**\r\n * 配置文件 - 管理外部资源路径和诗歌形式\r\n */\r\n\r\nimport type { LanguageConfig, SonnetForm, MeterPattern } from './types';\r\n\r\n// GitHub 仓库配置\r\nexport const GITHUB_CONFIG = {\r\n  // 开发仓库（存放源代码和数据文件）\r\n  devRepo: {\r\n    owner: 'ShioLilia',\r\n    name: 'sonnetaw',\r\n    branch: 'main'\r\n  },\r\n  \r\n  // 托管仓库（仅存放构建产物）\r\n  pagesRepo: {\r\n    owner: 'ShioLilia',\r\n    name: 'ShioLilia.github.io',\r\n    branch: 'main'\r\n  }\r\n};\r\n\r\n// 通用格律模式定义\r\nconst IAMBIC_PENTAMETER: MeterPattern = {\r\n  name: 'Iambic Pentameter',\r\n  description: 'Unstressed-stressed pattern, 10 syllables per line',\r\n  stressPattern: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\r\n  syllableCount: 10\r\n};\r\n\r\nconst IAMBIC_HEXAMETER: MeterPattern = {\r\n  name: 'Iambic Hexameter',\r\n  description: 'Unstressed-stressed pattern, 12 syllables per line',\r\n  stressPattern: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\r\n  syllableCount: 12\r\n};\r\n\r\n// 英语诗歌形式\r\nconst ENGLISH_FORMS: SonnetForm[] = [\r\n  {\r\n    id: 'shakespearean',\r\n    name: 'Shakespearean Sonnet',\r\n    description: 'ABAB CDCD EFEF GG',\r\n    rhymeScheme: ['A', 'B', 'A', 'B', 'C', 'D', 'C', 'D', 'E', 'F', 'E', 'F', 'G', 'G'],\r\n    meter: IAMBIC_PENTAMETER,\r\n    lineCount: 14\r\n  },\r\n  {\r\n    id: 'petrarchan1',\r\n    name: 'Petrarchan Sonnet (CDECDE)',\r\n    description: 'ABBAABBA CDECDE',\r\n    rhymeScheme: ['A', 'B', 'B', 'A', 'A', 'B', 'B', 'A', 'C', 'D', 'E', 'C', 'D', 'E'],\r\n    meter: IAMBIC_PENTAMETER,\r\n    lineCount: 14\r\n  },\r\n  {\r\n    id: 'petrarchan2',\r\n    name: 'Petrarchan Sonnet (CDCDCD)',\r\n    description: 'ABBAABBA CDCDCD',\r\n    rhymeScheme: ['A', 'B', 'B', 'A', 'A', 'B', 'B', 'A', 'C', 'D', 'C', 'D', 'C', 'D'],\r\n    meter: IAMBIC_PENTAMETER,\r\n    lineCount: 14\r\n  }\r\n];\r\n\r\n// 支持的语言列表（包含各自的诗歌形式）\r\nexport const SUPPORTED_LANGUAGES: LanguageConfig[] = [\r\n  {\r\n    code: 'en',\r\n    name: 'English',\r\n    dictionaryFile: 'eng-cmu.json',\r\n    poeticForms: ENGLISH_FORMS\r\n  },\r\n  // 添加拉丁语示例：\r\n  // {\r\n  //   code: 'la',\r\n  //   name: 'Latin',\r\n  //   dictionaryFile: 'latin-prosody.json',\r\n  //   poeticForms: [\r\n  //     {\r\n  //       id: 'dactylic_hexameter',\r\n  //       name: 'Dactylic Hexameter',\r\n  //       description: 'Classical epic meter (Homer, Virgil)',\r\n  //       rhymeScheme: [], // No rhyme scheme\r\n  //       meter: DACTYLIC_HEXAMETER,\r\n  //       lineCount: 0 // Variable\r\n  //     },\r\n  //     {\r\n  //       id: 'elegiac_couplet',\r\n  //       name: 'Elegiac Couplet',\r\n  //       description: 'Hexameter + Pentameter',\r\n  //       rhymeScheme: [],\r\n  //       meter: ELEGIAC_METER,\r\n  //       lineCount: 2\r\n  //     }\r\n  //   ]\r\n  // },\r\n  // 古希腊语示例：\r\n  // {\r\n  //   code: 'grc',\r\n  //   name: 'Ancient Greek',\r\n  //   dictionaryFile: 'greek-prosody.json',\r\n  //   poeticForms: [\r\n  //     {\r\n  //       id: 'sapphic_stanza',\r\n  //       name: 'Sapphic Stanza',\r\n  //       description: 'Three sapphic lines + one adonic',\r\n  //       rhymeScheme: [],\r\n  //       meter: SAPPHIC_METER,\r\n  //       lineCount: 4\r\n  //     }\r\n  //   ]\r\n  // }\r\n];\r\n\r\n// 生成 GitHub raw 文件 URL\r\nexport function getRawUrl(repo: typeof GITHUB_CONFIG.devRepo, filePath: string): string {\r\n  return `https://raw.githubusercontent.com/${repo.owner}/${repo.name}/${repo.branch}/${filePath}`;\r\n}\r\n\r\n// 生成词典 URL（根据语言代码）\r\nexport function getDictionaryUrl(languageCode: string): string {\r\n  const language = SUPPORTED_LANGUAGES.find(lang => lang.code === languageCode);\r\n  if (!language) {\r\n    throw new Error(`Unsupported language: ${languageCode}`);\r\n  }\r\n  return getRawUrl(GITHUB_CONFIG.devRepo, `public/data/${language.dictionaryFile}`);\r\n}\r\n\r\n// 数据文件路径（兼容旧代码）\r\nexport const DATA_URLS = {\r\n  cmuDict: getDictionaryUrl('en') // 默认英语\r\n};\r\n","import { DictionaryService } from './dictionary';\r\nimport { SonnetAnalyzer } from './analyzer';\r\nimport type { SonnetAnalysis, LineAnalysis, SonnetForm } from './types';\r\nimport { getDictionaryUrl, SUPPORTED_LANGUAGES } from './config';\r\n\r\n// Initialize services\r\nconst dictionary = new DictionaryService();\r\nconst analyzer = new SonnetAnalyzer(dictionary);\r\n\r\n// Dictionary loading state\r\nlet dictionaryLoaded = false;\r\nlet currentLanguage = 'en'; // 当前使用的语言\r\nlet currentForm: SonnetForm | null = null; // 当前选择的诗歌形式\r\n\r\n// Check if running in Tauri (desktop app)\r\nconst isTauri = '__TAURI__' in window;\r\n\r\n// Load dictionary from remote source (web) or local file (Tauri)\r\nasync function loadDictionary(languageCode: string = 'en') {\r\n  try {\r\n    let dictionaryData;\r\n    dictionaryLoaded = false; // 重置状态\r\n    \r\n    if (isTauri) {\r\n      // Desktop app: load from bundled local file\r\n      console.log(`Loading dictionary from local file (Tauri mode) - Language: ${languageCode}...`);\r\n      const language = SUPPORTED_LANGUAGES.find(lang => lang.code === languageCode);\r\n      if (!language) {\r\n        throw new Error(`Unsupported language: ${languageCode}`);\r\n      }\r\n      const response = await fetch(`/data/${language.dictionaryFile}`);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to load local dictionary: ${response.statusText}`);\r\n      }\r\n      dictionaryData = await response.json();\r\n      console.log(`Dictionary loaded successfully from local file - ${language.name}`);\r\n    } else {\r\n      // Web app: load from GitHub (saves hosting space)\r\n      console.log(`Loading dictionary from GitHub (web mode) - Language: ${languageCode}...`);\r\n      const dictionaryUrl = getDictionaryUrl(languageCode);\r\n      const response = await fetch(dictionaryUrl);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to load dictionary: ${response.statusText}`);\r\n      }\r\n      dictionaryData = await response.json();\r\n      console.log('Dictionary loaded successfully from GitHub repository');\r\n    }\r\n    \r\n    await dictionary.loadDictionary(dictionaryData, languageCode);\r\n    currentLanguage = languageCode;\r\n    dictionaryLoaded = true;\r\n  } catch (error) {\r\n    console.error('Error loading dictionary:', error);\r\n    const errorMsg = isTauri \r\n      ? 'Failed to load pronunciation dictionary from local files.'\r\n      : 'Failed to load pronunciation dictionary. Please check your internet connection.';\r\n    alert(errorMsg);\r\n  }\r\n}\r\n\r\n// Load dictionary on startup\r\nloadDictionary();\r\n\r\n// DOM elements\r\nconst languageSelect = document.getElementById('languageSelect') as HTMLSelectElement;\r\nconst poemInput = document.getElementById('poemInput') as HTMLTextAreaElement;\r\nconst sonnetForm = document.getElementById('sonnetForm') as HTMLSelectElement;\r\nconst analyzeBtn = document.getElementById('analyzeBtn') as HTMLButtonElement;\r\nconst output = document.getElementById('output') as HTMLDivElement;\r\n\r\n// Populate language selector\r\nfunction initLanguageSelector() {\r\n  languageSelect.innerHTML = '';\r\n  for (const lang of SUPPORTED_LANGUAGES) {\r\n    const option = document.createElement('option');\r\n    option.value = lang.code;\r\n    option.textContent = lang.name;\r\n    if (lang.code === currentLanguage) {\r\n      option.selected = true;\r\n    }\r\n    languageSelect.appendChild(option);\r\n  }\r\n}\r\n\r\n// Populate poetic form selector based on current language\r\nfunction updateFormSelector() {\r\n  sonnetForm.innerHTML = '';\r\n  const language = SUPPORTED_LANGUAGES.find(lang => lang.code === currentLanguage);\r\n  \r\n  if (!language || language.poeticForms.length === 0) {\r\n    const option = document.createElement('option');\r\n    option.textContent = 'No forms available';\r\n    option.disabled = true;\r\n    sonnetForm.appendChild(option);\r\n    currentForm = null;\r\n    return;\r\n  }\r\n\r\n  for (const form of language.poeticForms) {\r\n    const option = document.createElement('option');\r\n    option.value = form.id;\r\n    option.textContent = form.name;\r\n    option.title = form.description;\r\n    sonnetForm.appendChild(option);\r\n  }\r\n  \r\n  // Set the first form as current\r\n  if (language.poeticForms.length > 0) {\r\n    currentForm = language.poeticForms[0];\r\n  }\r\n}\r\n\r\n// Handle language change\r\nlanguageSelect.addEventListener('change', async () => {\r\n  const newLanguage = languageSelect.value;\r\n  if (newLanguage !== currentLanguage) {\r\n    console.log(`Switching language to: ${newLanguage}`);\r\n    output.innerHTML = '<p style=\"color: #999; font-style: italic;\">Loading dictionary...</p>';\r\n    await loadDictionary(newLanguage);\r\n    if (dictionaryLoaded) {\r\n      updateFormSelector(); // Update available forms\r\n      output.innerHTML = '<p style=\"color: #999; font-style: italic;\">Dictionary loaded. Ready to analyze.</p>';\r\n    }\r\n  }\r\n});\r\n\r\n// Handle form change\r\nsonnetForm.addEventListener('change', () => {\r\n  const formId = sonnetForm.value;\r\n  const language = SUPPORTED_LANGUAGES.find(lang => lang.code === currentLanguage);\r\n  if (language) {\r\n    currentForm = language.poeticForms.find(form => form.id === formId) || null;\r\n  }\r\n});\r\n\r\n// Initialize selectors\r\ninitLanguageSelector();\r\nupdateFormSelector();\r\n\r\n/**\r\n * Get color for rhyme scheme letter\r\n */\r\nfunction getRhymeColor(letter: string): string {\r\n  const colors: { [key: string]: string } = {\r\n    'A': '#8B4513', // Saddle Brown\r\n    'B': '#4682B4', // Steel Blue  \r\n    'C': '#6B8E23', // Olive Drab\r\n    'D': '#B8860B', // Dark Goldenrod\r\n    'E': '#8B008B', // Dark Magenta\r\n    'F': '#CD5C5C', // Indian Red\r\n    'G': '#2F4F4F', // Dark Slate Gray\r\n    'H': '#556B2F', // Dark Olive Green\r\n  };\r\n  return colors[letter] || '#666';\r\n}\r\n\r\n/**\r\n * Find which rhyme group has issues and which lines to highlight\r\n */\r\nfunction getRhymeErrorLines(analysis: SonnetAnalysis): Set<number> {\r\n  const errorLines = new Set<number>();\r\n  \r\n  // Check each rhyme group\r\n  for (const [letter, lineIndices] of Object.entries(analysis.rhymeGroups)) {\r\n    if (lineIndices.length <= 1) continue; // Skip single-line groups\r\n    \r\n    // Get rhyme keys for this group\r\n    const rhymeKeys = lineIndices.map(i => analysis.lines[i].rhymeKey);\r\n    const validRhymes = rhymeKeys.filter(r => r !== '');\r\n    const uniqueRhymes = new Set(validRhymes);\r\n    \r\n    // If there are mismatches, highlight the minority lines\r\n    if (uniqueRhymes.size > 1) {\r\n      const rhymeCounts = new Map<string, number[]>();\r\n      lineIndices.forEach((lineIdx, i) => {\r\n        const key = rhymeKeys[i];\r\n        if (!rhymeCounts.has(key)) {\r\n          rhymeCounts.set(key, []);\r\n        }\r\n        rhymeCounts.get(key)!.push(lineIdx);\r\n      });\r\n      \r\n      // Find the rhyme with fewer occurrences\r\n      let minCount = Infinity;\r\n      let minorityLines: number[] = [];\r\n      for (const [key, lines] of rhymeCounts.entries()) {\r\n        if (lines.length < minCount) {\r\n          minCount = lines.length;\r\n          minorityLines = lines;\r\n        }\r\n      }\r\n      \r\n      // Mark minority lines as errors\r\n      minorityLines.forEach(idx => errorLines.add(idx));\r\n    }\r\n  }\r\n  \r\n  return errorLines;\r\n}\r\n\r\n/**\r\n * Render a single line with syllable highlighting\r\n */\r\nfunction renderLine(line: LineAnalysis, rhymeLetter: string, analysis: SonnetAnalysis, rhymeErrorLines: Set<number>): HTMLElement {\r\n  const lineDiv = document.createElement('div');\r\n  lineDiv.className = 'line';\r\n  \r\n  // Check if this line has meter issues (skip lines with too few/many syllables)\r\n  const shouldCheckMeter = line.words.length > 0 && \r\n    Math.abs(line.stressPattern.length - (line.expectedStressPattern?.length || 10)) <= 2;\r\n  \r\n  if (shouldCheckMeter && !line.meterValid) {\r\n    lineDiv.classList.add('meter-invalid');\r\n  }\r\n\r\n  // Line number\r\n  const lineNumber = document.createElement('span');\r\n  lineNumber.className = 'line-number';\r\n  lineNumber.textContent = `${line.lineNumber}.`;\r\n  lineDiv.appendChild(lineNumber);\r\n\r\n  // Render each word with syllables\r\n  for (const word of line.words) {\r\n    const wordSpan = document.createElement('span');\r\n    wordSpan.className = 'word';\r\n\r\n    if (word.found && word.syllables.length > 0) {\r\n      // Create a wrapper with stress pattern shown via background\r\n      const wordText = word.originalWord;\r\n      \r\n      // For simplicity, highlight the whole word based on whether it has primary stress\r\n      const hasPrimaryStress = word.syllables.some(s => s.stress === 1);\r\n      const hasSecondaryStress = word.syllables.some(s => s.stress === 2);\r\n      \r\n      let stressClass = 'stress-0';\r\n      if (hasPrimaryStress) {\r\n        stressClass = 'stress-1';\r\n      } else if (hasSecondaryStress) {\r\n        stressClass = 'stress-2';\r\n      }\r\n      \r\n      const syllableSpan = document.createElement('span');\r\n      syllableSpan.className = `syllable ${stressClass}`;\r\n      syllableSpan.textContent = wordText;\r\n      \r\n      // Check if any syllable has meter error (only if line should be checked)\r\n      if (shouldCheckMeter && !line.meterValid && line.expectedStressPattern) {\r\n        let globalSyllableIndex = 0;\r\n        // Calculate starting position in line\r\n        for (const w of line.words) {\r\n          if (w === word) break;\r\n          globalSyllableIndex += w.syllables.length;\r\n        }\r\n        \r\n        // Check each syllable\r\n        for (let i = 0; i < word.syllables.length; i++) {\r\n          const syllable = word.syllables[i];\r\n          const expectedIndex = globalSyllableIndex + i;\r\n          if (expectedIndex < line.expectedStressPattern.length) {\r\n            const expected = line.expectedStressPattern[expectedIndex];\r\n            const actual = syllable.stress;\r\n            // Mark as error if stress doesn't match expectation\r\n            if ((expected === 1 && actual !== 1) || (expected === 0 && actual === 1)) {\r\n              syllableSpan.classList.add('meter-error');\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      syllableSpan.title = `Syllables: ${word.syllables.length}, Stress pattern: ${word.syllables.map(s => s.stress).join('')}`;\r\n      wordSpan.appendChild(syllableSpan);\r\n    } else {\r\n      // Word not found in dictionary - add gray background\r\n      const notFoundSpan = document.createElement('span');\r\n      notFoundSpan.className = 'word-not-found';\r\n      notFoundSpan.textContent = word.originalWord;\r\n      notFoundSpan.title = 'Word not found in dictionary';\r\n      wordSpan.appendChild(notFoundSpan);\r\n    }\r\n\r\n    lineDiv.appendChild(wordSpan);\r\n    lineDiv.appendChild(document.createTextNode(' '));\r\n  }\r\n\r\n  // Add rhyme marker with color and optional error highlight\r\n  const rhymeMarker = document.createElement('span');\r\n  rhymeMarker.className = 'rhyme-marker';\r\n  rhymeMarker.textContent = rhymeLetter;\r\n  rhymeMarker.style.color = getRhymeColor(rhymeLetter);\r\n  \r\n  // Highlight rhyme marker if this line has a rhyme error\r\n  if (rhymeErrorLines.has(line.lineNumber - 1)) {\r\n    rhymeMarker.classList.add('rhyme-error');\r\n  }\r\n  \r\n  lineDiv.appendChild(rhymeMarker);\r\n\r\n  // Add line text as tooltip\r\n  lineDiv.title = line.text;\r\n\r\n  return lineDiv;\r\n}\r\n\r\n/**\r\n * Render the complete analysis\r\n */\r\nfunction renderAnalysis(analysis: SonnetAnalysis): void {\r\n  output.innerHTML = '';\r\n\r\n  // Get rhyme error lines\r\n  const rhymeErrorLines = getRhymeErrorLines(analysis);\r\n\r\n  // Render lines\r\n  const linesContainer = document.createElement('div');\r\n  analysis.lines.forEach((line, index) => {\r\n    const rhymeLetter = analysis.form.rhymeScheme[index] || '?';\r\n    const lineElement = renderLine(line, rhymeLetter, analysis, rhymeErrorLines);\r\n    linesContainer.appendChild(lineElement);\r\n  });\r\n  output.appendChild(linesContainer);\r\n\r\n  // Render summary\r\n  const summary = document.createElement('div');\r\n  summary.className = 'summary';\r\n\r\n  const summaryTitle = document.createElement('h3');\r\n  summaryTitle.textContent = 'Analysis Summary';\r\n  summary.appendChild(summaryTitle);\r\n\r\n  // Form info\r\n  const formInfo = document.createElement('div');\r\n  formInfo.className = 'summary-item';\r\n  formInfo.innerHTML = `<strong>Form:</strong> ${analysis.form.name}<br>\r\n                        <strong>Expected Meter:</strong> ${analysis.form.meter.name} (${analysis.form.meter.description})<br>\r\n                        <strong>Expected Rhyme Scheme:</strong> ${analysis.form.rhymeScheme.join('')}`;\r\n  summary.appendChild(formInfo);\r\n\r\n  // Meter validation\r\n  const meterItem = document.createElement('div');\r\n  meterItem.className = `summary-item ${analysis.meterValid ? 'valid' : 'invalid'}`;\r\n  meterItem.innerHTML = `<strong>Meter:</strong> ${analysis.meterValid ? '✓ Valid' : '✗ Issues Found'}`;\r\n  \r\n  if (!analysis.meterValid && analysis.meterIssues.length > 0) {\r\n    analysis.meterIssues.forEach(issue => {\r\n      const issueDiv = document.createElement('div');\r\n      issueDiv.className = 'issue';\r\n      issueDiv.textContent = issue;\r\n      meterItem.appendChild(issueDiv);\r\n    });\r\n  }\r\n  summary.appendChild(meterItem);\r\n\r\n  // Rhyme scheme validation\r\n  const rhymeItem = document.createElement('div');\r\n  rhymeItem.className = `summary-item ${analysis.rhymeSchemeValid ? 'valid' : 'invalid'}`;\r\n  rhymeItem.innerHTML = `<strong>Rhyme Scheme:</strong> ${analysis.rhymeSchemeValid ? '✓ Valid' : '✗ Issues Found'}`;\r\n  \r\n  if (!analysis.rhymeSchemeValid && analysis.rhymeIssues.length > 0) {\r\n    analysis.rhymeIssues.forEach(issue => {\r\n      const issueDiv = document.createElement('div');\r\n      issueDiv.className = 'issue';\r\n      issueDiv.textContent = issue;\r\n      rhymeItem.appendChild(issueDiv);\r\n    });\r\n  }\r\n  summary.appendChild(rhymeItem);\r\n\r\n  output.appendChild(summary);\r\n}\r\n\r\n/**\r\n * Handle analyze button click\r\n */\r\nanalyzeBtn.addEventListener('click', () => {\r\n  const text = poemInput.value.trim();\r\n\r\n  if (!text) {\r\n    alert('Please enter a sonnet to analyze.');\r\n    return;\r\n  }\r\n\r\n  if (!dictionaryLoaded) {\r\n    alert('Dictionary is still loading. Please wait a moment and try again.');\r\n    return;\r\n  }\r\n\r\n  if (!currentForm) {\r\n    alert('Please select a poetic form.');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const analysis = analyzer.analyzeSonnet(text, currentForm);\r\n    renderAnalysis(analysis);\r\n  } catch (error) {\r\n    console.error('Analysis error:', error);\r\n    output.innerHTML = `<p style=\"color: red;\">Error analyzing sonnet: ${error}</p>`;\r\n  }\r\n});\r\n\r\n// Load sample sonnet\r\nconst sampleSonnet = `Shall I compare thee to a summer's day\r\nThou art more lovely and more temperate\r\nRough winds do shake the darling buds of May\r\nAnd summer's lease hath all too short a date\r\nSometime too hot the eye of heaven shines\r\nAnd often is his gold complexion dimmed\r\nAnd every fair from fair sometime declines\r\nBy chance or nature's changing course untrimmed\r\nBut thy eternal summer shall not fade\r\nNor lose possession of that fair thou owest\r\nNor shall death brag thou wanderest in his shade\r\nWhen in eternal lines to time thou grow\r\nSo long as men can breathe or eyes can see\r\nSo long lives this and this gives life to thee`;\r\n\r\npoemInput.value = sampleSonnet;\r\n\r\nconsole.log('Sonnet Checker loaded successfully!');\r\n"],"names":["DictionaryService","dictData","languageCode","word","normalized","pronunciations","phonemes","syllables","currentSyllable","currentStress","phoneme","stressMatch","lastVowelIndex","i","p","rhymeKey","tokenizeLine","line","removePunctuation","SonnetAnalyzer","dictionary","lineText","lineNumber","words","wordAnalyses","stressPattern","cleaned","analysis","syllable","actual","expected","lines","expectedScheme","rhymeGroups","rhymeKeys","issues","letter","lineIndices","rhymes","validRhymes","r","uniqueRhymes","text","form","lineAnalyses","index","rhymeValidation","meterIssues","GITHUB_CONFIG","IAMBIC_PENTAMETER","ENGLISH_FORMS","SUPPORTED_LANGUAGES","getRawUrl","repo","filePath","getDictionaryUrl","language","lang","analyzer","dictionaryLoaded","currentLanguage","currentForm","isTauri","loadDictionary","dictionaryData","response","dictionaryUrl","error","languageSelect","poemInput","sonnetForm","analyzeBtn","output","initLanguageSelector","option","updateFormSelector","newLanguage","formId","getRhymeColor","getRhymeErrorLines","errorLines","rhymeCounts","lineIdx","key","minCount","minorityLines","idx","renderLine","rhymeLetter","rhymeErrorLines","lineDiv","shouldCheckMeter","wordSpan","wordText","hasPrimaryStress","s","hasSecondaryStress","stressClass","syllableSpan","globalSyllableIndex","w","expectedIndex","notFoundSpan","rhymeMarker","renderAnalysis","linesContainer","lineElement","summary","summaryTitle","formInfo","meterItem","issue","issueDiv","rhymeItem","sampleSonnet"],"mappings":"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"}